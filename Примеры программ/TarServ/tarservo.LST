C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TARSERVO
OBJECT MODULE PLACED IN tarservo.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe tarservo.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "tarservo.h"
   3          #include "init.h"
   4          #include "servo.h"
   5          #include <intrins.h>
   6          #include <float.h>
   7          
   8          #define NBFM            50
   9          xdata char BuferFromModem [NBFM]; // Для анализа с последовательного порта
  10          xdata char wBFM, rBFM, marBFM;   
  11          
  12          //xdata unsigned int Value[16]; 
  13          
  14          void UART0_isr(void);
  15          void UART1_isr(void);
  16          void Timer0_isr(void);
  17          
  18          //SPI------------------------------------------------------------------
  19          
  20          //-----------------------------------------------------------------------------
  21          // MMC_Command_Exec
  22          //-----------------------------------------------------------------------------
  23          //
  24          // This function generates the necessary SPI traffic for all MMC SPI commands.
  25          // The three parameters are described below:
  26          // 
  27          // cmd:      This parameter is used to index into the command table and read 
  28          //           the desired command.  The Command Table Index Constants allow the
  29          //           caller to use a meaningful constant name in the cmd parameter 
  30          //           instead of a simple index number.  For example, instead of calling 
  31          //           MMC_Command_Exec (0, argument, pchar) to send the MMC into idle 
  32          //           state, the user can call 
  33          //           MMC_Command_Exec (GO_IDLE_STATE, argument, pchar);
  34          //
  35          // argument: This parameter is used for MMC commands that require an argument.
  36          //           MMC arguments are 32-bits long and can be values such as an
  37          //           an address, a block length setting, or register settings for the
  38          //           MMC.
  39          //
  40          // pchar:    This parameter is a pointer to the local data location for MMC 
  41          //           data operations.  When a read or write occurs, data will be stored
  42          //           or retrieved from the location pointed to by pchar.
  43          //
  44          // The MMC_Command_Exec function indexes the command table using the cmd 
  45          // parameter. It reads the command table entry into memory and uses information
  46          // from that entry to determine how to proceed.  Returns the 16-bit card 
  47          // response value;
  48          //
  49          
  50          unsigned int MMC_Command_Exec (unsigned char cmd, unsigned long argument,
  51                                     unsigned char *pchar)
  52          {
  53   1         idata COMMAND current_command;      // Local space for the command table 
  54   1                                             // entry;
  55   1         idata ULONG long_arg;               // Union variable for easy byte 
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 2   

  56   1                                             // transfers of the argument;
  57   1                                             // Static variable that holds the 
  58   1                                             // current data block length;
  59   1         static unsigned long current_blklen = 512;
  60   1         unsigned long old_blklen = 512;     // Temp variable to preserve data block
  61   1                                             // length during temporary changes;
  62   1         idata unsigned int counter = 0;     // Byte counter for multi-byte fields;
  63   1         idata UINT card_response;           // Variable for storing card response;
  64   1         idata unsigned char data_resp;      // Variable for storing data response;
  65   1         idata unsigned char dummy_CRC;      // Dummy variable for storing CRC field;
  66   1      
  67   1                                             
  68   1         current_command = commandlist[cmd]; // Retrieve desired command table entry
  69   1                                             // from code space;
  70   1         SPI0DAT = 0xFF;                     // Send buffer SPI clocks to ensure no
  71   1         while(!SPIF){}                      // MMC operations are pending;
  72   1         SPIF = 0;
  73   1         NSSMD0 = 0;                         // Select MMC by pulling CS low;
  74   1         SPI0DAT = 0xFF;                     // Send another byte of SPI clocks;
  75   1         while(!SPIF){}
  76   1         SPIF = 0;
  77   1                                             // Issue command opcode;
  78   1         SPI0DAT = (current_command.command_byte | 0x40);
  79   1         long_arg.l = argument;              // Make argument byte addressable;
  80   1                                             // If current command changes block
  81   1                                             // length, update block length variable
  82   1                                             // to keep track;
  83   1                                             // Command byte = 16 means that a set
  84   1                                             // block length command is taking place
  85   1                                             // and block length variable must be
  86   1                                             // set;
  87   1         if(current_command.command_byte == 16)
  88   1         {
  89   2            current_blklen = argument;       
  90   2         }                                
  91   1                                             // Command byte = 9 or 10 means that a
  92   1                                             // 16-byte register value is being read
  93   1                                             // from the card, block length must be
  94   1                                             // set to 16 bytes, and restored at the
  95   1                                             // end of the transfer;
  96   1         if((current_command.command_byte == 9)||
  97   1            (current_command.command_byte == 10))
  98   1         {
  99   2            old_blklen = current_blklen;     // Command is a GET_CSD or GET_CID,
 100   2            current_blklen = 16;             // set block length to 16-bytes;
 101   2         }
 102   1         while(!SPIF){}                      // Wait for initial SPI transfer to end;
 103   1         SPIF = 0;                           // Clear SPI Interrupt flag;
 104   1      
 105   1                                             // If an argument is required, transmit
 106   1                                             // one, otherwise transmit 4 bytes of
 107   1                                             // 0x00;
 108   1         if(current_command.arg_required == YES)
 109   1         {
 110   2            counter = 0;
 111   2            while(counter <= 3)
 112   2            {
 113   3               SPI0DAT = long_arg.b[counter];
 114   3               counter++;
 115   3               while(!SPIF){}
 116   3               SPIF = 0;
 117   3            }
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 3   

 118   2         }
 119   1         else
 120   1         {
 121   2            counter = 0;
 122   2            while(counter <= 3)
 123   2            {
 124   3               SPI0DAT = 0x00;
 125   3               counter++;
 126   3               while(!SPIF){}
 127   3               SPIF = 0;
 128   3            }
 129   2         }
 130   1         SPI0DAT = current_command.CRC;      // Transmit CRC byte;  In all cases
 131   1         while(!SPIF){}                      // except CMD0, this will be a dummy
 132   1         SPIF = 0;                           // character;
 133   1      
 134   1                                             // The command table entry will indicate
 135   1                                             // what type of response to expect for
 136   1                                             // a given command;  The following 
 137   1                                             // conditional handles the MMC response;
 138   1         if(current_command.response == R1)  // Read the R1 response from the card;
 139   1         {
 140   2            do
 141   2            {
 142   3               SPI0DAT = 0xFF;               // Write dummy value to SPI so that 
 143   3               while(!SPIF){}                // the response byte will be shifted in;
 144   3               SPIF = 0;
 145   3               card_response.b[0] = SPI0DAT; // Save the response;
 146   3            }
 147   2            while((card_response.b[0] & BUSY_BIT));
 148   2         }
 149   1                                             // Read the R1b response;
 150   1         else if(current_command.response == R1b)
 151   1         {
 152   2            do
 153   2            {
 154   3               SPI0DAT = 0xFF;               // Start SPI transfer;
 155   3               while(!SPIF){}
 156   3               SPIF = 0;
 157   3               card_response.b[0] = SPI0DAT; // Save card response
 158   3            }
 159   2            while((card_response.b[0] & BUSY_BIT));
 160   2            do                               // Wait for busy signal to end;
 161   2            {
 162   3               SPI0DAT = 0xFF;               
 163   3               while(!SPIF){}
 164   3               SPIF = 0;
 165   3            }
 166   2            while(SPI0DAT == 0x00);          // When byte from card is non-zero,
 167   2         }                                   // card is no longer busy;
 168   1                                             // Read R2 response
 169   1         else if(current_command.response == R2)
 170   1         {
 171   2            do
 172   2            {
 173   3               SPI0DAT = 0xFF;               // Start SPI transfer;
 174   3               while(!SPIF){}
 175   3               SPIF = 0;
 176   3               card_response.b[0] = SPI0DAT; // Read first byte of response;
 177   3            }
 178   2            while((card_response.b[0] & BUSY_BIT));
 179   2            SPI0DAT = 0xFF;
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 4   

 180   2            while(!SPIF){}
 181   2            SPIF = 0;
 182   2            card_response.b[1] = SPI0DAT;    // Read second byte of response;
 183   2         }
 184   1         else                                // Read R3 response;
 185   1         {
 186   2            do
 187   2            {
 188   3               SPI0DAT = 0xFF;               // Start SPI transfer;
 189   3               while(!SPIF){}
 190   3               SPIF = 0;
 191   3               card_response.b[0] = SPI0DAT; // Read first byte of response;
 192   3            }
 193   2            while((card_response.b[0] & BUSY_BIT));
 194   2            counter = 0;
 195   2            while(counter <= 3)              // Read next three bytes and store them
 196   2            {                                // in local memory;  These bytes make up
 197   3               counter++;                    // the Operating Conditions Register
 198   3               SPI0DAT = 0xFF;               // (OCR);
 199   3               while(!SPIF){}
 200   3               SPIF = 0;
 201   3               *pchar++ = SPI0DAT;
 202   3            }
 203   2         }
 204   1         switch(current_command.trans_type)  // This conditional handles all data 
 205   1         {                                   // operations;  The command entry
 206   2                                             // determines what type, if any, data
 207   2                                             // operations need to occur;
 208   2            case RD:                         // Read data from the MMC;
 209   2               do                            // Wait for a start read token from
 210   2               {                             // the MMC;
 211   3                  SPI0DAT = 0xFF;            // Start a SPI transfer;
 212   3                  while(!SPIF){}
 213   3                  SPIF = 0;
 214   3               }
 215   2               while(SPI0DAT != START_SBR);  // Check for a start read token;
 216   2               counter = 0;                  // Reset byte counter;
 217   2                                             // Read <current_blklen> bytes;
 218   2               while(counter < (unsigned int)current_blklen)
 219   2               {
 220   3                  SPI0DAT = 0x00;            // Start SPI transfer;
 221   3                  while(!SPIF){}
 222   3                  SPIF = 0;
 223   3                  *pchar++ = SPI0DAT;        // Store data byte in local memory;
 224   3                  counter++;                 // Increment data byte counter;
 225   3               }
 226   2               SPI0DAT = 0x00;               // After all data is read, read the two
 227   2               while(!SPIF){}                // CRC bytes;  These bytes are not used
 228   2               SPIF = 0;                     // in this mode, but the placeholders 
 229   2               dummy_CRC = SPI0DAT;          // must be read anyway;
 230   2               SPI0DAT = 0x00;
 231   2               while(!SPIF){}
 232   2               SPIF = 0;
 233   2               dummy_CRC = SPI0DAT;
 234   2               break;
 235   2            case WR:                         // Write data to the MMC;
 236   2               SPI0DAT = 0xFF;               // Start by sending 8 SPI clocks so
 237   2               while(!SPIF){}                // the MMC can prepare for the write;
 238   2               SPIF = 0;
 239   2               SPI0DAT = START_SBW;          // Send the start write block token;
 240   2               while(!SPIF){}
 241   2               SPIF = 0;
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 5   

 242   2               counter = 0;                  // Reset byte counter;
 243   2                                             // Write <current_blklen> bytes to MMC;
 244   2               while(counter < (unsigned int)current_blklen)
 245   2               {
 246   3                  SPI0DAT = *pchar++;        // Write data byte out through SPI;
 247   3                  while(!SPIF){}
 248   3                  SPIF = 0;
 249   3                  counter++;                 // Increment byte counter;
 250   3               }
 251   2      
 252   2               SPI0DAT = 0xFF;               // Write CRC bytes (don't cares);
 253   2               while(!SPIF){}
 254   2               SPIF = 0;
 255   2               SPI0DAT = 0xFF;
 256   2               while(!SPIF){}
 257   2               SPIF = 0;
 258   2      
 259   2               do                            // Read Data Response from card;
 260   2               {                             
 261   3                  SPI0DAT = 0xFF;
 262   3                  while(!SPIF){}
 263   3                  SPIF = 0;
 264   3                  data_resp = SPI0DAT;
 265   3               }                             // When bit 0 of the MMC response
 266   2                                             // is clear, a valid data response
 267   2                                             // has been received;
 268   2               while((data_resp & DATA_RESP_MASK) != 0x01);
 269   2      
 270   2               do                            // Wait for end of busy signal;
 271   2               {
 272   3                  SPI0DAT = 0xFF;            // Start SPI transfer to receive
 273   3                  while(!SPIF){}             // busy tokens;
 274   3                  SPIF = 0;
 275   3               }
 276   2               while(SPI0DAT == 0x00);       // When a non-zero token is returned,
 277   2                                             // card is no longer busy;
 278   2               SPI0DAT = 0xFF;               // Issue 8 SPI clocks so that all card
 279   2               while(!SPIF){}                // operations can complete;
 280   2               SPIF = 0;
 281   2               break;
 282   2            default: break;
 283   2         }
 284   1         SPI0DAT = 0xFF;
 285   1         while(!SPIF){}
 286   1         SPIF = 0;
 287   1      
 288   1      
 289   1         NSSMD0 = 1;                         // Deselect memory card;
 290   1         SPI0DAT = 0xFF;                     // Send 8 more SPI clocks to ensure
 291   1         while(!SPIF){}                      // the card has finished all necessary
 292   1         SPIF = 0;                           // operations;
 293   1                                             // Restore old block length if needed;
 294   1         if((current_command.command_byte == 9)||
 295   1            (current_command.command_byte == 10))
 296   1         {
 297   2            current_blklen = old_blklen;
 298   2         }
 299   1         return card_response.i;
 300   1      }
 301          
 302          
 303          
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 6   

 304          //-----------------------------------------------------------------------------
 305          // MMC_FLASH_Init
 306          //-----------------------------------------------------------------------------
 307          //
 308          // This function initializes the flash card, configures it to operate in SPI
 309          // mode, and reads the operating conditions register to ensure that the device
 310          // has initialized correctly.  It also determines the size of the card by 
 311          // reading the Card Specific Data Register (CSD).
 312          
 313          void MMC_FLASH_Init (void)
 314          {
 315   1         idata UINT card_status;             // Stores card status returned from 
 316   1                                             // MMC function calls(MMC_Command_Exec);
 317   1         idata unsigned char counter = 0;    // SPI byte counter;
 318   1         idata unsigned int size;            // Stores size variable from card;
 319   1         unsigned char xdata *pchar;         // Xdata pointer for storing MMC 
 320   1                                             // register values;
 321   1                                             // Transmit at least 64 SPI clocks
 322   1                                             // before any bus comm occurs.
 323   1         pchar = (unsigned char xdata*)LOCAL_BLOCK;
 324   1         for(counter = 0; counter < 8; counter++)
 325   1         {
 326   2            SPI0DAT = 0xFF;
 327   2            while(!SPIF){}
 328   2            SPIF = 0;
 329   2         }
 330   1         NSSMD0 = 0;                         // Select the MMC with the CS pin;
 331   1                                             // Send 16 more SPI clocks to 
 332   1                                             // ensure proper startup;
 333   1         for(counter = 0; counter < 2; counter++)
 334   1         {
 335   2            SPI0DAT = 0xFF;
 336   2            while(!SPIF){}
 337   2            SPIF = 0;
 338   2         }
 339   1                                             // Send the GO_IDLE_STATE command with
 340   1                                             // CS driven low;  This causes the MMC
 341   1                                             // to enter SPI mode;
 342   1         card_status.i = MMC_Command_Exec(GO_IDLE_STATE,EMPTY,EMPTY);
 343   1                                             // Send the SEND_OP_COND command
 344   1         do                                  // until the MMC indicates that it is
 345   1         {                                   // no longer busy (ready for commands);
 346   2            SPI0DAT = 0xFF;
 347   2            while(!SPIF){}
 348   2            SPIF = 0;
 349   2            card_status.i = MMC_Command_Exec(SEND_OP_COND,EMPTY,EMPTY);
 350   2         }
 351   1         while ((card_status.b[0] & 0x01));
 352   1         SPI0DAT = 0xFF;                     // Send 8 more SPI clocks to complete
 353   1         while(!SPIF){}                      // the initialization sequence;
 354   1         SPIF = 0;
 355   1         do                                  // Read the Operating Conditions 
 356   1         {                                   // Register (OCR);
 357   2            card_status.i = MMC_Command_Exec(READ_OCR,EMPTY,pchar);
 358   2         }
 359   1         while(!(*pchar&0x80));              // Check the card busy bit of the OCR;
 360   1      
 361   1         card_status.i = MMC_Command_Exec(SEND_STATUS,EMPTY,EMPTY);
 362   1                                             // Get the Card Specific Data (CSD)
 363   1                                             // register to determine the size of the
 364   1                                             // MMC;
 365   1         card_status.i = MMC_Command_Exec(SEND_CSD,EMPTY,pchar);
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 7   

 366   1         pchar += 9;                         // Size indicator is in the 9th byte of
 367   1                                             // CSD register;
 368   1                                             // Extract size indicator bits;
 369   1         size = (unsigned int)((((*pchar) & 0x03) << 1) | 
 370   1                               (((*(pchar+1)) & 0x80) >> 7));
 371   1         switch(size)                        // Assign PHYSICAL_SIZE variable to 
 372   1         {                                   // appropriate size constant;
 373   2            case 1: PHYSICAL_SIZE = PS_8MB; break;
 374   2            case 2: PHYSICAL_SIZE = PS_16MB; break;
 375   2            case 3: PHYSICAL_SIZE = PS_32MB; break;
 376   2            case 4: PHYSICAL_SIZE = PS_64MB; break;
 377   2            case 5: PHYSICAL_SIZE = PS_128MB; break;
 378   2            default: break;
 379   2         }
 380   1                                             // Determine the number of MMC sectors;
 381   1         PHYSICAL_BLOCKS = PHYSICAL_SIZE / PHYSICAL_BLOCK_SIZE;
 382   1         LOG_SIZE = PHYSICAL_SIZE - LOG_ADDR;
 383   1      }
 384          //-----------------------------------------------------------------------------
 385          // MMC_FLASH_Read
 386          //-----------------------------------------------------------------------------
 387          //
 388          // This function reads <length> bytes of FLASH from MMC address <address>, and
 389          // stores them in external RAM at the location pointed to by <pchar>.
 390          // There are two cases that must be considered when performing a read.  If the
 391          // requested data is located entirely in a single FLASH block, the function
 392          // sets the read length appropriately and issues a read command.  If requested
 393          // data crosses a FLASH block boundary, the read operation is broken into two
 394          // parts.  The first part reads data from the starting address to the end of 
 395          // the starting block, and then reads from the start of the next block to the
 396          // end of the requested data.  Before each read, the read length must be set
 397          // to the proper value.
 398          /*
 399          unsigned char MMC_FLASH_Read (unsigned long address, unsigned char *pchar,
 400                                   unsigned int length)
 401          {
 402             idata unsigned long flash_page_1;   // Stores address of first FLASH page;
 403             idata unsigned long flash_page_2;   // Stores address of second FLASH page;
 404             idata unsigned int card_status;     // Stores MMC status after each MMC
 405                                                 // command;
 406          
 407             if(length > 512) return 0;          // Test for valid data length;  Length
 408                                                 // must be less than 512 bytes;
 409                                                 // Find address of first FLASH block;
 410             flash_page_1 = address & ~(PHYSICAL_BLOCK_SIZE-1);
 411                                                 // Find address of second FLASH block;
 412             flash_page_2 = (address+length-1) & ~(PHYSICAL_BLOCK_SIZE-1);
 413             if(flash_page_1 == flash_page_2)    // Execute the following if data is 
 414             {                                   // located within one FLASH block;
 415                                                 // Set read length to requested data
 416                                                 // length;
 417                card_status = MMC_Command_Exec(SET_BLOCKLEN,(unsigned long)length,
 418                                           EMPTY);
 419                                                 // Issue read command;
 420                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,address,pchar);
 421             }
 422             else                                // Execute the following if data crosses
 423             {                                   // MMC block boundary;
 424                                                 // Set the read length to the length
 425                                                 // from the starting address to the
 426                                                 // end of the first FLASH page;
 427                card_status = MMC_Command_Exec(SET_BLOCKLEN,
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 8   

 428                                          (unsigned long)(flash_page_2 - address),
 429                                           EMPTY);
 430                                                 // Issue read command;
 431                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,address,pchar);
 432                                                 // Set read length to the length from
 433                                                 // the start of the second FLASH page
 434                                                 // to the end of the data;
 435                card_status = MMC_Command_Exec(SET_BLOCKLEN,
 436                                          (unsigned long)length - 
 437                                          (flash_page_2 - address),
 438                                           EMPTY);
 439                                                 // Issue second read command;  Notice
 440                                                 // that the incoming data stored in 
 441                                                 // external RAM must be offset from the
 442                                                 // original pointer value by the length
 443                                                 // of data stored during the first read 
 444                                                 // operation;
 445                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_2,
 446                                           pchar + (flash_page_2 - address));
 447             }
 448          }
 449          */
 450          //-----------------------------------------------------------------------------
 451          // MMC_FLASH_Clear
 452          //-----------------------------------------------------------------------------
 453          //
 454          // This function erases <length> bytes of flash starting at address <address>.
 455          // The <scratch> pointer points to a 512 byte area of XRAM that can
 456          // be used as temporary storage space.  The flow of this function is similar
 457          // to the FLASH_Read function in that there are two possible cases.  If the
 458          // space to be cleared is contained within one MMC block, the block can be
 459          // stored locally and erased from the MMC.  Then the desired area can be 
 460          // cleared in the local copy and the block can be written back to the MMC.  If 
 461          // the desired clear area crosses a FLASH block boundary, the previous steps 
 462          // must be executed seperately for both blocks.
 463          /*
 464          unsigned char MMC_FLASH_Clear (unsigned long address, unsigned char *scratch,
 465                                    unsigned int length)
 466          {
 467             idata unsigned long flash_page_1;   // Stores address of first FLASH page;
 468             idata unsigned long flash_page_2;   // Stores address of second FLASH page;
 469             idata unsigned int card_status;     // Stores MMC status after each MMC
 470                                                 // command;
 471             idata unsigned int counter;         // Counter for clearing bytes in local
 472                                                 // block copy;
 473             unsigned char xdata *index;         // Index into local block used for 
 474                                                 // clearing desired data;
 475             if(length > 512) return 0;          // Test desired clear length;  If 
 476                                                 // length > 512, break out and return
 477                                                 // zero;
 478                                                 // Calculate first FLASH page address;
 479             flash_page_1 = address & ~(PHYSICAL_BLOCK_SIZE-1);
 480                                                 // Calculate second FLASH page address;
 481             flash_page_2 = (address+length-1) & ~(PHYSICAL_BLOCK_SIZE-1);
 482             if(flash_page_1 == flash_page_2)    // Clear space all in one FLASH block
 483             {                                   // condition;
 484                                                 // Read first FLASH block;
 485                card_status = MMC_Command_Exec(SET_BLOCKLEN,
 486                                           (unsigned long)PHYSICAL_BLOCK_SIZE,
 487                                           EMPTY);
 488                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_1,scratch);
 489                                                 // Set index to address of area to clear
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 9   

 490                                                 // in local block;
 491                index = (unsigned int)(address % PHYSICAL_BLOCK_SIZE) + scratch;
 492                counter = 0;
 493                while(counter<length)            // Clear desired area in local block;
 494                {
 495                   *index++ = 0x00;
 496                   counter++;
 497                }
 498                                                 // Tag first FLASH page for erase;
 499                card_status = MMC_Command_Exec(TAG_SECTOR_START,flash_page_1,EMPTY);
 500                card_status = MMC_Command_Exec(TAG_SECTOR_END,flash_page_1,EMPTY);
 501                                                 // Erase first FLASH page;
 502                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 503                                                 // Write local copy of block back out
 504                                                 // to MMC;
 505                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_1,scratch);
 506             }
 507             else                                // Clear space crosses FLASH block
 508             {                                   // boundaries condition;
 509                                                 // Follow same procedure as for single
 510                                                 // block case above;  Read first block
 511                                                 // clear data from start address to end
 512                                                 // of block;  Erase block in FLASH;
 513                                                 // Write local copy back out;
 514                card_status = MMC_Command_Exec(SET_BLOCKLEN,
 515                                           (unsigned long)PHYSICAL_BLOCK_SIZE,
 516                                           EMPTY);
 517                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_1,scratch);
 518                index = (unsigned int)(address % PHYSICAL_BLOCK_SIZE) + scratch;
 519                counter = (unsigned int)(flash_page_2 - address);
 520                while(counter > 0)
 521                {
 522                   *index++ = 0xFF;
 523                   counter--;
 524                }
 525                card_status = MMC_Command_Exec(TAG_SECTOR_END,flash_page_1,EMPTY);
 526                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 527                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_1,scratch);
 528                                                 // Same process as above, but using
 529                                                 // second FLASH block;  Area to be
 530                                                 // cleared extends from beginning of
 531                                                 // second FLASH block to end of desired
 532                                                 // clear area;
 533                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_2,scratch);
 534                index = scratch;
 535                counter = (unsigned int)(length - (flash_page_2 - address));
 536                while(counter > 0)
 537                {
 538                   *index++ = 0xFF;
 539                   counter--;
 540                }
 541                card_status = MMC_Command_Exec(TAG_SECTOR_END,flash_page_2,EMPTY);
 542                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 543                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_2,scratch);
 544             }
 545          }
 546          */
 547          //-----------------------------------------------------------------------------
 548          // MMC_FLASH_Write
 549          //-----------------------------------------------------------------------------
 550          //
 551          // This function operates much like the MMC_FLASH_Clear and MMC_FLASH_Read
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 10  

 552          // functions.  As with the others, if the desired write space crosses a FLASH 
 553          // block boundary, the operation must be broken into two pieces.  
 554          // MMC_FLASH_Write uses the MMC_FLASH_Clear function to clear the write space 
 555          // before issuing any writes.  The desired write space is cleared using 
 556          // MMC_FLASH_Clear, then the data is read in, the previously cleared write 
 557          // space is modified, and the data is written back out.
 558          //
 559          // While it would be more efficient to avoid the MMC_FLASH_Clear and simply 
 560          // perform a read-modify-write operation, using MMC_FLASH_Clear helps make the 
 561          // process easier to understand.
 562          /*
 563          unsigned char MMC_FLASH_Write (unsigned long address, unsigned char *scratch,
 564                                    unsigned char *wdata, unsigned int length)
 565          {
 566             idata unsigned long flash_page_1;   // First FLASH page address;
 567             idata unsigned long flash_page_2;   // Second FLASH page address;
 568             idata unsigned int card_status;     // Stores status returned from MMC;
 569             idata unsigned int counter;         // Byte counter used for writes to 
 570                                                 // local copy of data block;
 571             unsigned char xdata *index;         // Pointer into local copy of data
 572                                                 // block, used during modification;
 573             MMC_FLASH_Clear(address,scratch,length); // Clear desired write space;
 574             if(length > 512) return 0;          // Check for valid data length;
 575                                                 // Calculate first FLASH page address;
 576             flash_page_1 = address & ~(PHYSICAL_BLOCK_SIZE-1);
 577                                                 // Calculate second FLASH page address;
 578             flash_page_2 = (address+length-1) & ~(PHYSICAL_BLOCK_SIZE-1);
 579             if(flash_page_1 == flash_page_2)    // Handle single FLASH block condition;
 580             {
 581                                                 // Set block length to default block
 582                                                 // size (512 bytes);
 583                card_status = MMC_Command_Exec(SET_BLOCKLEN,
 584                                           (unsigned long)PHYSICAL_BLOCK_SIZE,
 585                                           EMPTY);
 586                                                 // Read data block;
 587                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_1,scratch);
 588                index = (unsigned int)(address % PHYSICAL_BLOCK_SIZE) + scratch;
 589                counter = 0;
 590                while(counter<length)            // Modify write space in local copy;
 591                {
 592                   *index++ = *wdata++;
 593                   counter++;
 594                }
 595                                                 // Write modified block back to MMC;
 596                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_1,scratch);
 597             }
 598             else                                // Handle multiple FLASH block 
 599             {                                   // condition;
 600                                                 // Set block length to default block
 601                                                 // size (512 bytes);
 602                card_status = MMC_Command_Exec(SET_BLOCKLEN,
 603                                           (unsigned long)PHYSICAL_BLOCK_SIZE,
 604                                           EMPTY);
 605                                                 // Read first data block;
 606                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_1,scratch);
 607                index = (unsigned int)(address % PHYSICAL_BLOCK_SIZE) + scratch;
 608                counter = (unsigned int)(flash_page_2 - address);
 609                while(counter > 0)               // Modify data in local copy of first
 610                {                                // block;
 611                   *index++ = *wdata++;
 612                   counter--;
 613                }
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 11  

 614                                                 // Write local copy back to MMC;
 615                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_1,scratch);
 616                                                 // Read second data block;
 617                card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,flash_page_2,scratch);
 618                index = scratch;
 619                counter = (unsigned int)(length - (flash_page_2 - address));
 620                while(counter > 0)               // Modify data in local copy of second
 621                {                                // block;
 622                   *index++ = *wdata++;
 623                   counter--;
 624                }
 625                                                 // Write local copy back to MMC;
 626                card_status = MMC_Command_Exec(WRITE_BLOCK,flash_page_2,scratch);
 627             }
 628          }
 629          */
 630          //-----------------------------------------------------------------------------
 631          // MMC_FLASH_MassErase
 632          //-----------------------------------------------------------------------------
 633          //
 634          // This function erases <length> bytes of flash starting with the block
 635          // indicated by <address1>.  This function only handles sector-sized erases
 636          // or larger.  Function should be called with sector-aligned erase addresses.
 637          /*
 638          unsigned char MMC_FLASH_MassErase (unsigned long address1, 
 639                                             unsigned long length)
 640          {
 641             idata unsigned char card_status;    // Stores card status returned from MMC;
 642                                                 // Store start and end sectors to be
 643                                                 // to be erased;
 644             idata unsigned long flash_page_1, flash_page_2;
 645                                                 // Store start and end groups to be
 646                                                 // erased;
 647             idata unsigned long flash_group_1, flash_group_2;
 648                                                 // Compute first sector address for 
 649                                                 // erase;
 650             flash_page_1 = address1 & ~(PHYSICAL_BLOCK_SIZE-1);
 651                                                 // Compute first group address for 
 652                                                 // erase;
 653             flash_group_1 = flash_page_1 &~(PHYSICAL_GROUP_SIZE-1);
 654                                                 // Compute last sector address for 
 655                                                 // erase;
 656             flash_page_2 = (address1 + length) & ~(PHYSICAL_BLOCK_SIZE-1);
 657                                                 // Compute last group address for erase;
 658             flash_group_2 = flash_page_2 &~(PHYSICAL_GROUP_SIZE-1);
 659          
 660             if(flash_group_1 == flash_group_2)  // Handle condition where entire erase
 661             {                                   // space is in one erase group;
 662                                                 // Tag first sector;
 663                card_status = MMC_Command_Exec(TAG_SECTOR_START,flash_page_1,EMPTY);
 664                                                 // Tag last sector;
 665                card_status = MMC_Command_Exec(TAG_SECTOR_END,flash_page_2,EMPTY);
 666                                                 // Issue erase command;
 667                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 668             }
 669             else                                // Handle condition where erase space
 670             {                                   // crosses an erase group boundary;
 671                                                 // Tag first erase sector;
 672                card_status = MMC_Command_Exec(TAG_SECTOR_START,flash_page_1,EMPTY);
 673                                                 // Tag last sector of first group;
 674                card_status = MMC_Command_Exec(TAG_SECTOR_END,
 675                                          (flash_group_1 + 
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 12  

 676                                          (unsigned long)(PHYSICAL_GROUP_SIZE 
 677                                          - PHYSICAL_BLOCK_SIZE)),EMPTY);
 678                                                 // Issue erase command;
 679                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 680                                                 // Tag first sector of last erase group;
 681                card_status = MMC_Command_Exec(TAG_SECTOR_START,flash_group_2,EMPTY);
 682                                                 // Tag last erase sector;
 683                card_status = MMC_Command_Exec(TAG_SECTOR_END,flash_page_2,EMPTY);
 684                                                 // Issue erase;
 685                card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 686                                                 // Conditional that erases all groups
 687                                                 // between first and last group;
 688                if(flash_group_2 > (flash_group_1 + PHYSICAL_GROUP_SIZE))
 689                {
 690                                                 // Tag first whole group to be erased;
 691                   card_status = MMC_Command_Exec(TAG_ERASE_GROUP_START,
 692                                             (flash_group_1 + 
 693                                             (unsigned long)PHYSICAL_GROUP_SIZE),EMPTY);
 694                                                 // Tag last whole group to be erased;
 695                   card_status = MMC_Command_Exec(TAG_ERASE_GROUP_END,
 696                                             (flash_page_2 - 
 697                                             (unsigned long)PHYSICAL_GROUP_SIZE),EMPTY);
 698                                                 // Issue erase command;
 699                   card_status = MMC_Command_Exec(ERASE,EMPTY,EMPTY);
 700                }
 701             }
 702          
 703             return card_status;
 704          }
 705          */
 706          //-----------------------------------------------------------------------
 707          void main(void)
 708          {
 709   1              //Для работы с последовательным портом "Модем"
 710   1              xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 711   1              unsigned int Value;     
 712   1      
 713   1              WDTCN = 0xde;                   //Стоп сторожевой таймер
 714   1              WDTCN = 0xad;
 715   1      //   WDTCN = 0x07;         // Макс время = 0,021 с
 716   1      
 717   1         FLSCL = FLSCL | 1;   //Разрешение стирания/записи FLASH памяти
 718   1      
 719   1              port_init(); 
 720   1              sysclk();
 721   1              SPI_Init ();    
 722   1              UART0_Init();   
 723   1              UART1_Init(); 
 724   1              DAC0_init();    
 725   1              ADC_init();
 726   1              Timer0_init(); 
 727   1              MMC_FLASH_Init();
 728   1      
 729   1              config();
 730   1      //      EA = 0;
 731   1      
 732   1      //      DAC0 = 0x00;
 733   1      
 734   1              rBFM = wBFM = marBFM = 0;
 735   1              for(PWM = 1; PWM < 15; PWM++)
 736   1              {
 737   2                      Value = 37500;
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 13  

 738   2                      write(PWM+112, Value);
 739   2              }
 740   1                      
 741   1              while(1)        
 742   1              {
 743   2              if(rBFM < wBFM+marBFM*NBFM)
 744   2              {
 745   3                              if ((BuferFromModem[rBFM] & 0xC0) == 0x40)      
 746   3                              {
 747   4                                      nByte = 0;
 748   4                                      KontrSumma = 0;
 749   4                                      PWM = BuferFromModem[rBFM] & 0x3f;
 750   4                              }
 751   3                              if (nByte > 25)
 752   3                                      nByte = 25;
 753   3                              RK_code[nByte] = BuferFromModem[rBFM] & 0x7f;
 754   3                              KontrSumma = KontrSumma^RK_code[nByte++];
 755   3      
 756   3                              if ( (nByte == 5) && (KontrSumma == 0) )
 757   3                              {
 758   4                                      Value = RK_code[1]+((unsigned int)RK_code[2] << 7)+((unsigned int)RK_code[3] << 14);
 759   4                                      write(PWM+112, Value);
 760   4                              }
 761   3      
 762   3               rBFM++;
 763   3                              if(rBFM >= NBFM)
 764   3                              {
 765   4                              rBFM = 0;
 766   4                                      marBFM = 0;     
 767   4                              }
 768   3            }
 769   2                      
 770   2              }       //while (1)
 771   1              return;
 772   1      }
 773          
 774          //-------------------------------------------------------------------
 775          void UART0_isr(void) interrupt 4
 776          {
 777   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 778   1              SFRPAGE = UART0_PAGE;
 779   1              
 780   1              if (RI0)  
 781   1              { 
 782   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 783   2                      if(wBFM >= NBFM)
 784   2                      {
 785   3                      wBFM = 0;
 786   3                              marBFM = 1;     
 787   3                      }      
 788   2                      RI0 = 0;                
 789   2              }
 790   1              if (TI0)
 791   1                      TI0 = 0;
 792   1      
 793   1              SFRPAGE = SFRPAGE_SAVE;
 794   1              return;
 795   1      }
 796          
 797          //---------------------------------------------------------------------------------
 798          void UART1_isr(void) interrupt 20
 799          {
C51 COMPILER V9.00   TARSERVO                                                              03/27/2012 13:33:28 PAGE 14  

 800   1              xdata char SFRPAGE_SAVE = SFRPAGE;//, tmp;
 801   1              SFRPAGE = UART1_PAGE;                                                     
 802   1      
 803   1              if (RI1)  
 804   1                      RI1 = 0;
 805   1      
 806   1              TI1 = 0;
 807   1              SFRPAGE = SFRPAGE_SAVE;
 808   1              return;
 809   1      }
 810          
 811          //----------------------------------------------------------------------
 812          void TIMER0_ISR (void) interrupt 1
 813          {
 814   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 815   1              SFRPAGE = 0;
 816   1      
 817   1              TH0 = 0xAE;     // 0xFFFF-49766400/48/FREQ = 0xAEFF
 818   1              TL0 = 0xFF;     
 819   1      
 820   1              SFRPAGE = SFRPAGE_SAVE;
 821   1              return;
 822   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1629    ----
   CONSTANT SIZE    =    150    ----
   XDATA SIZE       =    851      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      16
   IDATA SIZE       =   ----      21
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
